local ls = require("luasnip")
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node

return {
    s("qq", {
        t({
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define int long long",
            "#define INF 1000000000000000000LL",
            "#define print cout << setprecision(20)",
            "#define MOD 1'000'000'007",
            "#define inarr(n, a)\\",
            "    vector<int> a(n);\\",
            "    for (int i = 0; i < n; i++) cin >> a[i];",
            "#define outarr(ans)\\",
            "    for (auto i : ans) cout << i << ' ';\\",
            "    cout << endl;",
            "#define NP\\",
            "\t{\\",
            "\t\tcout<<-1<<endl;\\",
            "\t\tcontinue;\\",
            "\t}",
            "map<int, int> freq(const vector<int> &a) {",
            "    map<int, int> freqs;",
            "    for (auto i : a) freqs[i]++;",
            "    return freqs;",
            "}",
            "vector<int> PS(const vector<int> &a) {",
            "    int n = a.size();",
            "    vector<int> aa(n);",
            "    for (int i = 0; i < n; i++) aa[i] = a[i] + (i == 0 ? 0 : aa[i - 1]);",
            "    return aa;",
            "}",
            "int modexp(int a, int n){",
            "    if(n==0) return 1;",
            "    if(n==1) return a;",
            "    if(n&1) return (a*modexp(a,n-1))%MOD;",
            "    int i=modexp(a,n/2)%MOD;",
            "    return (i*i)%MOD;",
            "}",
            "",
            "////////////////////////////////////////////////////////////////////////////////////////",
            "",
            "int32_t main(){",
            "    cin.tie(0), cout.tie(0);",
            "    ios::sync_with_stdio(false);",
            "    int t;",
            "    cin >> t;",
            "    while (t--) {",
            "        ",
        }),
        i(1),
        t({
            "",
            "    }",
            "}",
        }),
    }),

    s("DisjointSet", {
        t({
            "class DisjointSet {",
            "\tvector<int> size, parent;",
            "\tpublic:",
            "\tDisjointSet(int n) {",
            "\t\tsize.resize(n + 1, 1);",
            "\t\tparent.resize(n + 1);",
            "\t\tfor (int i = 0; i <= n; i++) {",
            "\t\t\tparent[i] = i;",
            "\t\t}",
            "\t}",
            "",
            "\tint FindUpar(int u) {",
            "\t\tif (u == parent[u]) return u;",
            "\t\treturn parent[u] = FindUpar(parent[u]);",
            "\t}",
            "",
            "\tvoid UnionBySize(int u, int v) {",
            "\t\tint Up_u = FindUpar(u), Up_v = FindUpar(v);",
            "\t\tif (Up_u == Up_v) return;",
            "\t\tif (size[Up_v] > size[Up_u]) {",
            "\t\t\tparent[Up_u] = Up_v;",
            "\t\t\tsize[Up_v] += size[Up_u];",
            "\t\t} else {",
            "\t\t\tparent[Up_v] = Up_u;",
            "\t\t\tsize[Up_u] += size[Up_v];",
            "\t\t}",
            "\t}",
            "};",
        }),
    }),

    s("segtree", {
        t({
            "template<typename T>",
            "class SegmentTree {",
            "private:",
            "    int n;",
            "    vector<T> tree;",
            "    vector<T> arr;",
            "    function<T(const T&, const T&)> combine;",
            "    T identity;",
            "",
            "    void build(int node, int l, int r) {",
            "        if (l == r) {",
            "            tree[node] = arr[l];",
            "            return;",
            "        }",
            "        int mid = (l + r) / 2;",
            "        build(2 * node, l, mid);",
            "        build(2 * node + 1, mid + 1, r);",
            "        tree[node] = combine(tree[2 * node], tree[2 * node + 1]);",
            "    }",
            "",
            "    T queryUtil(int node, int l, int r, int ql, int qr) {",
            "        if (qr < l || ql > r)",
            "            return identity;",
            "        if (ql <= l && r <= qr)",
            "            return tree[node];",
            "        int mid = (l + r) / 2;",
            "        T leftResult = queryUtil(2 * node, l, mid, ql, qr);",
            "        T rightResult = queryUtil(2 * node + 1, mid + 1, r, ql, qr);",
            "        return combine(leftResult, rightResult);",
            "    }",
            "",
            "    void updateUtil(int node, int l, int r, int idx, T val) {",
            "        if (l == r) {",
            "            tree[node] = val;",
            "            return;",
            "        }",
            "        int mid = (l + r) / 2;",
            "        if (idx <= mid)",
            "            updateUtil(2 * node, l, mid, idx, val);",
            "        else",
            "            updateUtil(2 * node + 1, mid + 1, r, idx, val);",
            "        tree[node] = combine(tree[2 * node], tree[2 * node + 1]);",
            "    }",
            "",
            "public:",
            "    SegmentTree(const vector<T>& input, function<T(const T&, const T&)> combineFunc, T id)",
            "        : combine(combineFunc), identity(id) {",
            "        arr = input;",
            "        n = arr.size();",
            "        tree.resize(4 * n, identity);",
            "        build(1, 0, n - 1);",
            "    }",
            "",
            "    T query(int l, int r) {",
            "        return queryUtil(1, 0, n - 1, l, r);",
            "    }",
            "",
            "    void update(int idx, T val) {",
            "        updateUtil(1, 0, n - 1, idx, val);",
            "    }",
            "};",
        }),
    }),
}
